---
description: 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법
---

# 다이나믹 프로그래밍 1 X

하지만 우리의 일생은 위 그리디처럼 항상 독립적으로 일어날 수 없습니다.\
과거에 의존적인 상황에서는 그럼 어떻게 해야 효율적인 판단을 내릴 수 있을까요?

이런 상황에서 우리는 복잡한 문제들을 여러 문제로 나누어 푸는 방법을 사용합니다. \
~~아주 Dynamic하죠..?~~

DP를 가장 쉽게 설명하는 방법은 바로 우리가 쉽게 접해왔던 피보나치 수열입니다.

![](<../.gitbook/assets/image (8).png>)

지금껏 피보나치 수열은 재귀함수로 많이 표현이 되어왔습니다.

![](<../.gitbook/assets/image (1).png>)

하지만 이러한 함수 호출은 매우 치명적입니다. 위 그림을 보면 f(1)과 f(0)이 여러 번 출력됨을 볼 수 있습니다. 알고리즘 코드를 짜다보면 파이썬 에러 중\
_RecursionError: maximum recursion depth exceeded in comparison._\
이 에러를 많이 보신 분들이 있을 텐데요. 이런 문제를 해결하기 위해 우리는 memoization, 즉 값을 저장해놓고 가져다 쓰는 방법을 사용할 수 있습니다. **Memoization**은 시간/공간적으로 크게 효율적입니다.

다음으로 우리가 문제에 접근할 수 있는 방법을 알아봅시다.

피보나치 수열을 알아갈 때 위처럼 f(5)을 찾기 위해 f(4)와 f(3)을 탐색하는 직관적인 관점이 있습니다. 이를 우리는 **Top Down** 방식이라고 합니다.

하지만 애초에 f(1)부터 차근차근 구해놓고 시작해보면 어떨까요?\
피보나치 수열을 나타낼 때 우리는 1 1 2 3 5 8 13 21 34 … 이런 식으로 앞에서부터생각해낼 수 있습니다. 이렇게 애초에 아래에서부터 차근차근 구해놓고 시작하는 것을 **Bottom up** 방식이라고 합니다.\


![](<../.gitbook/assets/image (9).png>)

다음 피보나치 수열을  BOTTOM-UP 형식으로 나타내면 다음과 같습니다.

```python
N = int(input())
dp = [0]*(N+1)

def fib(num):
    dp[num] = dp[num-1] + dp[num-2]
    
if N == 0 :
    print(0)
else :
    dp[1] = 1
    for i in range(2, N+1):
        fib(i)
    print(dp[N])
```

* DP중 bottom-up(상향식)방법은 1+2부터 시작해서 작은 수부터 N+1 길이의 dp를 채워주고 마지막 결과값을 반환합니다.
* 트리 모양의 피보나치 수에서 **밑(자식노드)에서부터** 구하기 시작하는 것입니다.



TOP-DOWN은 다음과 같습니다.

```python
N = int(input())
dp = [0]*(N+1)

def fib(num):
    if num <= 1 :
        return num
    elif dp[num] != 0:
        return dp[num]
    dp[num] = fib(num-1) + fib(num-2)
    return dp[num]
print(fib(N))
```

* DP중 Top-down(하향식)방법은 우리가 구하고자 하는 수를 먼저 입력받습니다. N=100이라고 가정해봅시다.\
  \-dp\[99] + dp\[98]을 가져와서 더해!라고 명령합니다.\
  \> 그래서 dp\[99]랑 dp\[98]이 뭔데?\
  \> dp\[99]와 dp\[98]를 찾기위해 fib\[99] 실행, fib\[98] 실행합니다.\
  \> 그 안에서 또 98 97을 가져와  하면서 **아래로 내려가는** 형식입니다.
* 그래서 계속 물어보며 내려가다가 값이 나오는\
  `if num <= 1 : return num`\
  이 조건에서 1과 0이 나오면서\
  그때부터 값이 채워지며 답하기 시작합니다.
* 이 때 elif를 보면, 만약 dp\[num]이 0이 아닌 경우 dp\[num]값을 가져오는 것을 볼 수 있습니다. 이것이 바로 **memoization**!

번외)  번외로, TOP DOWN 방식은 위에서 보는 것으로 알 수 있듯이 재귀함수로 구현됩니다. 파이썬은 Recursion의 한도가 시스템의 안정을 위해 정해져 있다는특징이  있습니다. 그래서 그 한도를 푸는 방법이 있는데, 맨 위에

```python
import sys     
sys.setrecursionlimit(10000)     #재귀의 한도를 10000까지 풀어준다.
```

이런 식으로 풀어주어야 하는 경우가 많습니다.

이 점이 파이썬이 C++에게 뒤쳐지는 이유인데요, 가끔 python으로는 풀리지 않은 백준 / 또는 대회 DP TOPDOWN 문제가 존재합니다. 하지만 코딩테스트에서는 그럴 일이 많이 없으니 걱정 마세요!



다음으로는 2차원으로 memoization하여 사용하는 DP 문제에 대해 알아볼까요?\


{% embed url="https://www.acmicpc.net/problem/11049" %}



\
\
2차원 DP - 행렬 곱셈 순서 (11049) 또는 17498 또는  13302\
\


\<TOP DOWN>

탑 다운 방식에 대해 설명 + 파이썬을 선호하지 않는 이유가 여기서 드러남 설명
